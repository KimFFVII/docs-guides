= Running Custom Applications in OneCX
:toc:

This guide walks you through the process of setting up, running, testing, and removing custom applications in the OneCX environment. It covers different ways to achieve these tasks using a custom "Hello World" application as an example. 

[#application-setup]
== 1 Application Setup

Before you run your custom application in OneCX, make sure all relevant application data, permissions, and permission assignments are present in the database. Therefore we need to define our application, microservice, Ui Component and register the application in our workspace. There are two main approaches to add the necessary data: You can either create the import files and update the container definitions manually, or you can use the `onecx-local-env-cli` to automate the process.

For both approaches please ensure your local OneCX environment is already set up and running correctly. For setup instructions, refer to the link:https://onecx.github.io/docs/onecx-local-env/current/general/index.html[onecx-local-env documentation].

[#manually-creating-import-files]
=== 1.1. Manually Creating Import Files and Docker Compose Entry
The first approach to set up the custom application in OneCX is to manually create the required JSON files in the imports folder and update the container definitions in the onecx-local-env repository.

[#creating-import-files]
==== Create Import Files
First we need to define our application by creating the following file in *imports > product-store > microfrontends*.

NOTE: The file name must match the shown pattern consisting of *product name* (here: hello-world), *microservice*(hello-world-ui) and *UI component*(main).

.hello-world_hello-world-ui_main.microfrontend.json
[source,json]
----
{
  "appVersion": "xxx",
  "appName": "hello-world",
  "description": "OneCX HelloWorld Module",
  "remoteBaseUrl": "/mfe/helloWorld/",
  "remoteEntry": "/mfe/helloWorld/remoteEntry.js",
  "note": "OneCX HelloWorld UI module auto import via MF operator",
  "exposedModule": "./HelloWorldModule",
  "technology": "WEBCOMPONENTMODULE",
  "remoteName": "hello-world",
  "tagName": "hello-world-webcomponent",
  "type": "MODULE",
  "deprecated": false,
  "undeployed": false
}
----

* The `appName` matches the product name.
* The `remoteBaseUrl` should match the routing path in your app's helm `values.yaml`.
* The `exposedModule` should match the module name, that is exposed in your app's webpack config.
* The `tagName` can be found in the remoteModule ts file in the ngDoBootstrap() function.

We also need to add the permissions for our application by creating the following file in *imports > product-store > permissions*.

.hello-world_hello-world-ui.json
[source,json]
----
{
  "name": "hello-world-ui",
  "permissions": [
    {
      "resource": "HELLO",
      "action": "CREATE"
    },
    {
      "resource": "HELLO",
      "action": "EDIT"
    },
    {
      "resource": "HELLO",
      "action": "DELETE"
    },
    {
      "resource": "HELLO",
      "action": "SAVE"
    },
    {
      "resource": "HELLO",
      "action": "IMPORT"
    },
    {
      "resource": "HELLO",
      "action": "EXPORT"
    },
    {
      "resource": "HELLO",
      "action": "VIEW"
    },
    {
      "resource": "HELLO",
      "action": "SEARCH"
    }
  ]
}
----

The permissions need to match the permissions defined in your applications `values.yaml`.

Then the UI microservice needs to be defined by creating the following file in *imports > product-store > microservices*.

NOTE: The file name must match the shown pattern consisting of *product name* (here: hello-world) and *microservice*(hello-world-ui).
For the bff and svc the same pattern applies, just replace *microservice* with the corresponding product names.

.hello-world_hello-world-ui.json
[source,json]
----
{
    "version": "xxx",
    "description": "hello-world-ui",
    "name": "hello-world-ui",
    "type": "ui"
}
----

* The name needs to match the name of the microservice.

We also need to add the product definition by creating the following file in *imports > product-store > products*.

NOTE: The file name must match the *product name* (here: hello-world).

.hello-world.json
[source,json]
----
{
    "version": "xxx",
    "description": "hello-world",
    "basePath": "/hello-world",
    "displayName": "hello-world",
    "iconName": "pi-briefcase"
}
----

* The `basePath` defines the URL path where the application will be accessible later.

To register the application in the workspace, we can add it to the `products` array in the `onecx_admin.json` file located in *imports > workspace*.

.onecx_admin.json
[source,json]
----
{
    "productName": "hello-world",
    "baseUrl": "/hello-world",
    "microfrontends": [
        {
            "appId": "hello-world-ui",
            "basePath": "/"
        }
    ]
},
----

* The `productName`, `basePath` and `appId` should match the values we used in the files we created before.

[#creating-docker-compose]
==== Create Docker Compose Entry
Now we need to add the container definition for our application by creating a new `hello-world.docker-compose.yaml` at the same level as the `docker-compose.yaml`. This file should define the image, environment variables, labels for traefik, network, and profiles. For our Hello World app, it looks like this:

.hello-world.docker-compose.yaml
[source,yaml]
----
include:
  - docker-compose.yaml
services:
  hello-world-ui:
    image: ${HELLO_WORLD_UI}
    environment:
      APP_BASE_HREF: /mfe/helloWorld/
      APP_ID: hello-world-ui
      PRODUCT_NAME: hello-world
    depends_on:
      hello-world-bff:
        condition: service_healthy
    labels:
      - traefik.http.services.hello-world-ui.loadbalancer.server.port=8080
      - traefik.http.routers.hello-world-ui.rule=Host(`local-proxy`)&&PathPrefix(`/mfe/helloWorld/`)
    networks:
      - default
    profiles:
      - base
----

* The environment variables should match the values we defined in the import files. (APP_BASE_HREF should match remoteBaseUrl in the microfrontend file)
* The `labels` section configures traefik for routing. The service will be accessible via port 8080 (the default exposed port for nginx) and the `PathPrefix` value should match the `APP_BASE_HREF`.
* The `profiles: base` entry ensures your service is included when starting the minimal local environment.

Once all files are in place, you can import your new app data to the database and start the environment as shown in the xref:import-data-and-start-environment[Import data and start environment] section below.

[#using-onecx-local-env-cli]
=== 1.2. Using onecx-local-env-cli

The second and faster approach to set up the custom application in the OneCX environment is to use the `onecx-local-env-cli` to automate the creation of import files and the docker compose entry.

NOTE: This method requires a correct Helm setup for your application. If Helm values are missing or incorrect, the CLI may not work as expected.

To sync the app with your local environment, navigate to your hello-world UI folder and run:

[source,sh]
----
npx @onecx/local-env-cli sync ui hello-world /hello-world ./helm/values.yaml -e /path/to/onecx-local-env -n hello-world-ui
----

In this command:

- `hello-world` refers to the product name.
- `/hello-world` specifies the product's base path.
- `./helm/values.yaml` is the path to the application's `values.yaml` file.

This command will update your onecx-local-env with the necessary information about your new application's UI.

To add the UI as an image to the `docker-compose.yaml` of your onecx-local-env, run (adjust the path as needed):

[source,sh]
----
npx @onecx/local-env-cli docker hello-world create hello-world helloWorld -e /path/to/onecx-local-env -s ui
----

A `hello-world.docker-compose.yaml` should now be created in the onecx-local-env, containing an image for `hello-world-ui`.

NOTE: In the same way as for the UI we can also handle the BFF and SVC of our application by using the commands in the xref:getting_started.adoc#creating-the-bff[ General Getting Started guide].

For more details regarding the usage of the CLI, see the link:https://github.com/onecx/onecx-local-env-cli/[onecx-local-env-cli README].

[#running-and-testing-applications]
== 2. Run and Test Local Applications in the OneCX Shell
We can use different ways to run and test our local application in the OneCX Shell regarding the use case and preferences.

[#automatic-image-build]
=== 2.1 Automatic Image Build

With the build context and the image specified in `docker-compose.yaml`, Docker will automatically build the image. 

For that the image name needs to be added to the `.env` file at the same level as your new `hello-world.docker-compose.yaml`. Create the file, if it doesn't exists yet and add the following lines:

[source,env]
----
HELLO_WORLD_SVC=${DOCKER_REPO}/hello-world-svc:main-native
HELLO_WORLD_BFF=${DOCKER_REPO}/hello-world-bff:main-native
HELLO_WORLD_UI=${DOCKER_REPO}/hello-world-ui:main
----

Now you can import the initial data by running:

[source,sh]
----
./import-onecx.sh
----

Now the application needs to be built with `npm run build` and the onecx-local-env can be started with:

[source,sh]
----
docker compose -f hello-world.docker-compose.yml --profile base up -d
----

NOTE: To ensure the application runs correctly, make sure to add entries for `hello-world-bff` and `hello-world-svc` to your system's hosts file (e.g., `C:\Windows\System32\drivers\etc\hosts` on Windows).

For more details on these commands and necessary configurations, refer to the link:https://onecx.github.io/docs/onecx-local-env/current/general/index.html[onecx-local-env documentation].

Now the application should be accessible under `http://local-proxy/mfe/helloWorld/hello` in the OneCX Shell.

*This method of running the application may lead to potential caching issues that could prevent changes from being reflected immediately.*

[#manual-image-build]
=== 2.2 Manual Image Build
To avoid caching issues and ensure the latest code is used, it is recommended to manually build the Docker image after building your app locally.

For that first go to your application and *remove the cache and dist folder to avoid using cached images*:

[source,sh]
----
rm -rf .nx/cache ./dist
----

Then you can build your application and create a local docker image:

[source,sh]
----
npm run build
docker build --no-cache -t helloworld_local .
----

The local images need to be added to your `.env` file in the onecx-local-env as shown xref:automatic-image-build[above], but the UI should refer to the locally built image:

[source,env]
----
HELLO_WORLD_SVC=${DOCKER_REPO}/hello-world-svc:main-native
HELLO_WORLD_BFF=${DOCKER_REPO}/hello-world-bff:main-native
HELLO_WORLD_UI=helloworld_local:latest
----

Now you can also import the initial data by running:

[source,sh]
----
./import-onecx.sh
----

and start the service with:

[source,sh]
----
docker compose -f hello-world.docker-compose.yml --profile base up -d
----

Now the local image is used and changes in the application should be reflected under `http://local-proxy/mfe/helloWorld/hello` after rebuilding the image of the application.

[#enable-hot-reload]
=== 2.3 Enable Hot Reload

For development purposes, you can enable hot reload in your local environment. This allows you to see changes in the application immediately without rebuilding the image.
For that we need to adjust the routing configuration in the traefik configurations of the docker image by replacing the labels section of the hello-world-ui service in the `hello-world.docker-compose.yaml` with the following lines.

[source,yaml]
----
- "traefik.http.routers.local_mfe.entrypoints=web"
- "traefik.http.routers.local_mfe.rule=Host(`local-proxy`)&&PathPrefix(`/mfe/helloWorld/`)"
- "traefik.http.routers.local_mfe.service=local_mfe@file"
----

Make sure the `PathPrefix` is set correctly.
Now, routing is handled directly to your locally running application instead of the Docker container.

To make sure, that traefik can access the local application, enhance the `npm start` script in the applications `package.json` with `--host 0.0.0.0 --disable-host-check`.

Additionally the PROXY_CONFIG in the `proxy.config.js` of the UI application needs to be updated like this. Note that the path needs to be adjusted accordingly.

[source,javascript]
----
const PROXY_CONFIG = {
  '/mfe/helloWorld': {
    target: 'http://localhost:4200/',
    secure: false,
    pathRewrite: {
      '^.*/mfe/helloWorld': '',
    },
    changeOrigin: true,
    logLevel: 'debug',
    bypass: bypassFn,
  }
}
----

If your app runs on the standard port 4200, no more configuration is needed, as this is already set up for the `local_mfe` service under `./init-data/traefik/traefik-services.yml` in the onecx-local-env. The traefik config in the `docker-compose.yaml` only needs to be changed, if a different port is used.

Now you can start your application with `npm start` and every change in the application should be reflected immediately under `http://local-proxy/mfe/helloWorld/hello`.

[#running-multiple-local-apps]
=== 2.4 Running Multiple Local Apps Simultaneously

You can add multiple custom apps to your `docker-compose.yaml` and run them together. Ensure each app has a unique name, port, and base path. Use the same build and run strategies as above for each app.

[#testing-changes-to-existing-onecx-core-apps]
=== 2.5 Testing Changes to Existing OneCX Core Apps

If you have made changes to an existing OneCX core app (e.g., OneCX Theme UI) it can be tested the same way as for custom applications.
Build the app locally and follow the xref:manual-image-build[manual image build process] above. Replace the image reference in `docker-compose.yaml` with your locally built image, start the environment and verify your changes in the OneCX Shell.

If you need to do changes in `shell-ui` and want to test your changes in the `onecx-local-env`, you can edit the `docker-compose.yaml` in your local environment and update the `onecx-shell-ui` service as follows:

[source,yaml]
----
onecx-shell-ui:
    # image: localhost/onecx-shell-ui:latest
    build:
        context: /path/to/onecx-shell-ui
        dockerfile: Dockerfile
----

With this configuration, Docker Compose will build the image from your local source. To build (or rebuild) the image and start the service, run:

[source,sh]
----
docker compose --profile base up -d
----

Now you can build the shell locally with `npm run build`, then rebuild the Docker image, and test your changes within the local environment.

[#removal-of-custom-app]
== 3. Clean Removal of a Custom App

To remove a previously loaded custom app:

* Remove the app's service definition from `docker-compose.yaml`.
* Delete any related import files (microfrontends, microservices, products, permissions) from the `imports` folders.
* Remove menu entries and product references from the `onecx_admin.json`.
* Re-import the data and restart the environment to ensure the app is fully removed by running:
[source,sh]
----
./import-onecx.sh
----
